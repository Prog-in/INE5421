package uai.helcio.t2.table;

import uai.helcio.t2.entities.Symbol;
import uai.helcio.t2.entities.Terminal;
import uai.helcio.t1.entities.Token;
import uai.helcio.t2.generators.SLRGenerator;
import uai.helcio.utils.AppLogger;

import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.stream.Collectors;

/**
 * The runtime engine for the SLR Parser.
 * <p>
 * This class implements the standard LR parsing algorithm shown in standard compiler texts.
 * It maintains a stack of states and consumes a stream of tokens from the lexical analyzer.
 * At each step, it consults the pre-generated parsing table (Action/Goto) to decide whether to:
 * <ul>
 * <li><b>Shift:</b> Push the next state onto the stack and consume the token.</li>
 * <li><b>Reduce:</b> Pop states from the stack corresponding to a production body and push the Goto state for the production head.</li>
 * <li><b>Accept:</b> Successfully terminate the parsing.</li>
 * <li><b>Error:</b> Report a syntax error if no valid entry exists in the table.</li>
 * </ul>
 * </p>
 */
public class SLRParser {

    /**
     * The parsing table generated during the design phase.
     * Maps a State Index -> (Lookahead Symbol -> Action).
     */
    private final Map<Integer, Map<Symbol, TableEntry>> parsingTable;

    /**
     * The parser stack used to keep track of the current state.
     * It strictly stores State Indices.
     */
    private final Stack<Integer> stack = new Stack<>();

    /**
     * Constructs a new SLR Parser with a specific parsing table.
     *
     * @param parsingTable The Action/Goto table generated by the {@link SLRGenerator}.
     */
    public SLRParser(Map<Integer, Map<Symbol, TableEntry>> parsingTable) {
        this.parsingTable = parsingTable;
    }

    /**
     * Executes the parsing process on a list of tokens.
     *
     * @param inputs The list of tokens identified by the lexical analysis phase.
     * @return {@code true} if the input is valid according to the grammar, {@code false} otherwise.
     */
    public boolean parse(List<Token> inputs) {
        // Initialize stack with state 0
        stack.clear();
        stack.push(0);

        // Append End-Of-File marker to input stream
        inputs.add(new Token(Terminal.END_REPR, "EOF"));

        int cursor = 0;

        while (true) {
            int currentState = stack.peek();
            Token currentToken = inputs.get(cursor);

            // Convert Token to Terminal entity for table lookup.
            // Ensures strict object equality for the END/EOF marker.
            Terminal symbol;
            if (currentToken.type().equals(Terminal.END_REPR)) {
                symbol = Terminal.END;
            } else {
                symbol = Terminal.of(currentToken.type());
            }

            // Retrieve the row for the current state
            Map<Symbol, TableEntry> row = parsingTable.get(currentState);

            if (row == null) {
                AppLogger.logger.error("Erro Sintático: Estado {} inválido (sem transições).", currentState);
                return false;
            }

            // Look up the action for the current lookahead symbol
            TableEntry action = row.get(symbol);

            if (action == null) {
                AppLogger.logger.error("Erro Sintático: Token inesperado {} no estado {}", currentToken, currentState);
                AppLogger.logger.debug("Esperado neste estado: {}", row.keySet());
                return false;
            }

            AppLogger.logger.info("State: {} | Input: {} | Action: {}",
                    stack.stream().map(Object::toString).collect(Collectors.joining(",")), currentToken, action);

            switch (action.type()) {
                case SHIFT -> {
                    // Push target state and advance input cursor
                    stack.push(action.targetState());
                    cursor++;
                }
                case REDUCE -> {
                    var prod = action.productionToReduce();

                    // Determine how many states to pop based on production body length.
                    // Epsilon productions have length 1 but consume 0 tokens/states.
                    int sizeToPop = prod.body().size();
                    if (sizeToPop == 1 && prod.body().getFirst().equals(Terminal.EPSILON)) {
                        sizeToPop = 0;
                    }

                    for (int i = 0; i < sizeToPop; i++) {
                        stack.pop();
                    }

                    // Determine the next state based on the GOTO table
                    int stateUncovered = stack.peek();
                    Map<Symbol, TableEntry> gotoRow = parsingTable.get(stateUncovered);

                    if (gotoRow == null || !gotoRow.containsKey(prod.head())) {
                        AppLogger.logger.error("Erro fatal no GOTO após redução de {}", prod.head());
                        return false;
                    }

                    // Push the GOTO state
                    int nextState = gotoRow.get(prod.head()).targetState();
                    stack.push(nextState);

                    AppLogger.logger.info("Redução: {} ::= {}", prod.head(), prod.body());
                }
                case ACCEPT -> {
                    AppLogger.logger.info("SUCESSO: Cadeia aceita pela gramática!");
                    return true;
                }
                case ERROR -> {
                    return false;
                }
            }
        }
    }
}